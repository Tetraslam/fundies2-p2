Merging Sokoban Code

In this assignment, we merged the Sokoban game implementation into two main files:

1. Sokoban.java - Contains all the game logic and implementation classes
2. ExamplesSokoban.java - Contains all the tests for the game

The merge required careful handling of dependencies between classes. Here's how we approached it:

1. Class Structure:
   - Replaced enums (Direction, GameColor) with proper classes that use string fields
   - Created type-checking methods to avoid instanceof and casting
   - Added factory classes for Direction and GameColor to ensure consistent instances
   - Added a Utils class for methods that don't belong to specific objects

2. Interface Organization:
   - IGroundType interface with implementations: EmptyGround, Target, Hole
   - ICellContent interface with implementations: EmptyContent, Wall, Crate, Trophy, Player
   - Each interface has type-checking methods to avoid instanceof checks

3. Dependency Handling:
   - Factory classes (DirectionFactory, GameColorFactory) to create and reuse objects
   - Cell class that composes IGroundType and ICellContent
   - SokobanLevel class that manages the game board and player movement
   - SokobanWorld class that handles rendering and input

4. Helper Methods:
   - Added stringToList to convert string arrays to ArrayLists
   - Added isOutOfBounds to check position validity before cell access
   - Enhanced error handling for positions outside the board

The most challenging aspect was making sure all the dependencies were properly initialized in a way that avoids null pointers while following the restrictions of not using static fields/methods. The factory pattern helped address this by providing consistent instances of objects.

For game logic, we had to carefully track state between moves and ensure proper handling of special cases like trophies on targets, objects falling into holes, and boundary checks when pushing objects.